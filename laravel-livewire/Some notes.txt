Curso: https://www.youtube.com/watch?v=Ax4pT8XDR-0&list=PLZ2ovOgdI-kWqCet33O0WezN14KShkwER&ab_channel=CodersFree



*Para comandos y demás fijarse que se esté dentro de carpeta con el proyecto: comando " cd .\laravel-livewire\ " para ir dentro



***Se tiene proyecto en Repo, por lo que consideraciones al momento de clonar:
-Si no está el archivo .env, generarlo, a partir de archivo "env.txt"
-Comando "composer install"
-Comando "npm install"
-Si marca errror: " Database file at path [C:\laragon\www\laravel-livewire\laravel-livewire\database\database.sqlite] does not exist. Ensure this is an absolute path to the database. (Connection: sqlite, SQL: select * from "sessions" where "id" = g1OjctZ0WYLkV9JqmeVnhVGLgadKYbccaB1mjk2M limit 1) ":
    *en archivo ".env" cambiar de "sqlite" a "mysql"
-Si marca error: " SQLSTATE[HY000] [1049] Unknown database 'laravel' (Connection: mysql, SQL: select * from `sessions` where `id` = VInTp5ld5Y5875EOnudYtDZfpC68BXtLOYOvrC7M limit 1) ":
    *comando " php artisan migrate " (si indica " The database 'laravel' does not exist on the 'mysql' connection. Would you like to create it? (yes/no) " poner "y", aunque sea para que jale por mientras, ya después si es el caso se cambiaría la referencia a otra BD)
-Si marca error: " Vite manifest not found at: C:\laragon\www\laravel-livewire\laravel-livewire\public\build/manifest.json "
    *Abrir una terminal y ejecutar comando "npm run dev" (esto es para que detecte Tailwind, ya que "@vite" es una directiva de Tailwind que se está empleando)
    *Abrir otra terminal y ejecutar "php artisan serve"



First notes:
Se empleará Jetstream también, por lo que se requiere Node.js. 
Cuando se instala Jetstream, también "viene incluido" Livewire (Esto por la parte de la instalación donde se elige que emplear para el Frontend... si es Livewire se trabajará con PHP y si es Inertia.js será con JS.), en este caso se trabajará con Livewire. Y se irá personalizando lo que genera Jetstream, así como agregando cosas.

Comandos empleados:
*Primero se creo repo en GitHub, se abrió VS Code, se abre terminal, nos cambiamos a escritorio (" cd .\Desktop\ "), ahora si: 
" git clone https://github.com/erickavendanoh/laravel-livewire.git "
*Abrimos la carpeta donde está creada la clonación*
" node -v " (para ver que Node si esté instalado)
" composer -v " (para ver que Composer si esté instalado)
" composer create-project laravel/laravel laravel-livewire "
" cd .\laravel-livewire\ "
" php artisan serve "  (para ver que jale)
" composer require laravel/jetstream "
" php artisan jetstream:install livewire "
*si pregunta si se quieren volver a correr las migraciones porque se agregaron nuevas: poner "y"
" npm install "
" npm run build "
" php artisan migrate "
" php artisan serve "  (para ver que jale)

Ya una vez creado proyecto de Laravel, junto con Jetsream, en ruta "/dashboard" se puede apreciar la vista "dashboard.blade.php" (nos referimos ahora a "dashboard.blade copy.php", que fue una copia del archivo "dashboard.blade.php" que se crea por defecto al principio cuando se crea el proyecto (es de la parte de Jetsream), ubicado en resources/views, pero como el original se fue modificando por eso se deja la copia como referencia), donde al analizarlo se puede ver que emplea como plantilla "app.blade.php" (igual que con "dashboard", al original de este que se crea cuando recién se crea el proyecto también se le creo una copia, "app.blade copy.php"), ubicado dentro de resources/views/layouts, el cual ya incluye las directivas de Livewire "@livewireStyles" y "@livewireScripts" que corresponden a los estilos y scripts que emplea Livewire respectivamente, por lo que las vistas que empleen "app.blade.php" como plantilla ya incluiran lo requerido para emplear Livewire, y asimismo se puede notar que "app.blade.php" actúa más como componente de blade que como plantilla (por uso de $slot y slots con nombre, a los cuales se les da valor cuando se emplea en otras vistas, en lugar de los "@yield()" y así). Dentro de esa vista "dashboard.blade.php" también se emplean componentes, como el correspondiente a "welcome.blade.php", ubicada en resources/views/components (de igual forma, se le creo su copia del archivo original que se crea recién creado el proyecto, "welcome.blade copy.php") (empleado usando "<x-welcome />" en "dashboard")

IMPORTANTE: POR MOTIVOS DE AGILIZAR LA TOMA DEL CURSO, NO SE ESTARÍAN TOMANDO NOTAS TAN RIGUROSAS COMO HA SIDO EN OTROS CASOS. LOS ARCHIVOS QUE SE GENERAN CUANDO RECIÉN SE CREA EL PROYECTO (PROPIOS DE LARAVEL, TAILWIND, JETSTREAM, ETC.) SE IRÁN MODIFICANDO, ES POR ELLO QUE SE HICIERON LAS COPIAS DE ALGUNOS DE LOS PRIMEROS ARCHIVOS QUE SE GENERAN AL PRINCIPIO CUANDO RECIÉN SE CREA UN PROYECTO CON ESAS TECNOLOGÍAS. PERO EN ADELANTE SERÁ SOLO IR TOMANDO EL CURSO "COMO VA" PRÁCTICAMENTE.
    *SI SE QUIEREN REPASAR CONCEPTOS DE COMPONENTES BLADE (DE CLASE Y ANÓNIMOS), ALGO DE JESTREAM Y/O IMPLEMENTACIÓN DE TAILWIND, VER REPO: https://github.com/erickavendanoh/laravel-jetsream-inicio-y-componentes-blade



Comandos and beyond:
" php artisan make:livewire ShowPosts "


Para que el contenido correspondiente a las vistas de los componentes se renderice correctamente, todo debe ir dentro de los <div> que se crean por defecto dentro de sus archivos .blade.php cuando estos se crean


Las dos formas de emplear un componente de Livewire dentro de una vista son:
@livewire('*nombre del componente*')  ("forma antigua")
<livewire:*nombre del componente* />  ("forma más actual")


*Importante: Cuandos se quieran reutilizar ciertas porciones de código (correspondientes a elementos que tienen la misma estructura y se emplean en varias partes de la página como pueden ser tablas, alerts, o secciones en general que se repitan en sitio web) que se repite y solo cambia algunos valores (que pueden ser pasados como parámetros) no se recomienda mucho usar los componentes de Livewire, sino en esos casos serían mejor los componentes de Blade. Los componentes de Livewire se emplearían para agregar reactividad (actualización o muestras de información sin necesidad de refrescar la página) en algunas partes o secciones de la página donde se requiera


" php artisan make:livewire *nombre de subcarpeta*/*nombre del componente* " (Para crear los archivos correspondientes al componente que se está creando dentro de una subcarpeta dentro de las de "Livewire" tanto en "app" como en "resources/views", donde si no existe esa subcarpeta la crea también) ej. " php artisan make:livewire Nav/ShowPosts "
Para llamarlos desde las vistas cuando es así, es igual, solo que anteponiendo el nombre de la carpeta y un "." donde va el nombre del componente


El primer componente creado fue "ShowPosts" (por tema de comentarios de funcionalidad de algunas cosas)


Los valores que se pasen como parámetros a un componente de Livewire desde las vistas corresponderán a los atributos en su clase (Back, archivo .php), y se pasarán: <livewire:show-posts title="Este es un titulo de prueba" />
En caso de que no se quiera asignar el valor al atributo directamente desde la vista, se puede emplear la función mount(), la cual no se llama explicitamente sino que lo que se le ponga como parámetro serán las variables a las que se les de valor desde las llamadas en las vistas del componente (donde el nombre del parámetro y la asignación del valor del mismo desde la vista deben corresponder), y ya dentro de esa función se le asigna ese valor al atributo correspondiente, el cual es el que se usa en el "front" (archivo blade.php) del componente


Si bien los componentes de Livewire se emplean en casos donde solo ciertas secciones o partes de una página requieren reactividad, también habrán casos de páginas completas que necesiten ser reactivas. Para esos casos se puede crear un componente que corresponderá a toda esa página y su Back (archivo .php) podrá fungir como controlador y su Front (archivo blade.php) podrá fungir como la vista de ese controlador (esto para aspectos del web.php, puediéndolos definir con rutas determinadas). Esto sería mejor que tener un controlador y una vista normales, donde dentro de esta se llamen un montón de componentes de Livewire (los cuales se tendrán que crear y definir previamente), y teniendo muchos más archivos.
